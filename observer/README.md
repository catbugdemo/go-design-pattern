## 什么是「观察者模式」？

> 观察者观察被观察者，被观察者通知观察者

我们用 "订阅通知" 翻译下「观察者模式」的概念，结果：
> 订阅者订阅主题，主题通知订阅者

- 两个对象
    - 被观察者 -> 主题
    - 观察者 -> 订阅者
- 两个动作
    - 订阅 -> 订阅者订阅主题
    - 通知 -> 主题发生变动通知订阅者

观察者的优势：

- 高内聚 -> 不同业务代码变动互不影响
- 可复用 -> 新的业务(就是新的订阅者)订阅不同接口(主题,就是这里的接口)
- 极易扩展 -> 新增接口(就是新增主题);新增业务(就是新增订阅者)

其实说白了，就是分布式架构中使用消息机制MQ 解耦业务的优势

## 什么真实业务场景可以用「观察者模式」？

> 所有发生变更，需要通知的业务场景

详细说：只要发生了某些变化，需要通知依赖了这些变化的具体事物的业务场景。
> 我们有哪些真实业务场景可以用「观察者模式」呢？

比如，订单逆向流，也就是订单成立之后的各种取消操作(本文不讨论售后)，主要有如下取消类型：

| 订单取消类型  |
|---------|
| 未支付取消订单 |
| 超时关单    |
| 已支付取消订单 |
| 取消发货单   |
| 拒收      |

订单逆向流业务中的变与不变：
- 变
  - 新增取消类型
  - 新增子操作
  - 修改某个子操作的逻辑
  - 取消类型和子操作的对应关系
- 不变
  - 已存在的取消类型
  - 已存在的子操作(在外界看来)

## 怎么用「观察者模式」？

### 代码建模
「观察者模式」的核心是两个接口：
- "主题"(被观察者)接口 `Observable`
  - 抽象方法 `Attach`:增加 "订阅者"
  - 抽象方法 `Detach`:删除 "订阅者"
  - 抽象方法 `Notify`:通知 "订阅者"
- "订阅者"(观察者)接口 `ObserverInterface`
  - 抽象方法 `Do`: 自身业务

订单逆向流的业务下，我们需要实现这两个接口:
- 具体订单取消的动作实现 "主题" 接口 `Observable`
- 子逻辑实现 "订阅者"接口 `ObserverInterface`




