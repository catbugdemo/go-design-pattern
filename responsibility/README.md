# 责任链模式

## 什么是「责任链模式」？
> 首先把一系列业务按职责划分成不同的对象，接着把这一系列对象构成一个链，
> 然后在这一系列对象中传递请求对象，直到被处理为止

我们从概念中可以看出责任链模式有如下明显的优势
- 按职责划分：解耦
- 对象链: 逻辑清晰

> 首先把一系列业务按职责划分成不同的对象，接着把这一系列对象构成一个链，
> 直到"链路结束"为止。(结束：异常结束，或链路执行完毕)

责任链模式的具体优势：
- 直观：一眼可观的业务调用过程
- 无限扩展：可无限扩展的业务逻辑
- 高度封装：复杂业务代码依然高度封装
- 极易被修改：复杂业务代码下修改代码值需要专注对应的业务类(结构体)文件即可，以及极易被调整的业务执行顺序

## 什么真实业务场景可以用「责任链模式(改)」？

满足如下要求的场景：
> 业务极度复杂的所有场景

任何杂乱无章的业务代码，都可以使用责任链模式(改)去重构、设计
> 我们有哪些真实业务场景可以用「责任链模式(改)」？

比如电商系统的下单接口，随着业务发展不断的发展，该接口会充斥着各种各样的业务逻辑。

## 怎么用「责任链模式(改)」

使用设计模式的四个步骤:
- 业务梳理
- 业务流程图
- 代码建模
- 代码 demo

### 业务梳理

### 业务流程图

### 代码建模
责任链模式主要类主要包含如下特性：
- 成员属性
  - `nextHandler`:下一个等待被调用的对象实例 —> 稳定不变的
- 成员方法
  - `SetNext`:把下一个对象的实例绑定到当前对象的`nextHandler`属性上 -> 稳定不变的
  - `Do`:当前对象业务逻辑入口-> 变化的
  - `Run`:调用当前对象的`Do`,`nextHandler`不为空则调用`nextHandler.Do` -> 稳定不变的

套用到下单接口伪代码实现如下:
```
一个父类(抽象类):

- 成员属性
    + `nextHandler`:下一个等待被调用的对象实例
- 成员方法
    + 实体方法`SetNext`:实现把下一个对象的实例绑定到当前对象的`nextHandler`属性上
    + 抽象方法`Do`:当前对象业务逻辑入口
    + 实体方法`Run`:实现调用当前对象的`Do`,`nextHandler`不为空则调用`nextHandler.Do`

子类一(参数校验)
- 继承抽象类父类
- 实现抽象方法`Do`:具体的参数校验逻辑

子类二(获取地址信息)
- 继承抽象类父类
- 实现抽象方法`Do`:具体的参数校验逻辑

子类三(获取地址信息)
- 继承抽象类父类
- 实现抽象方法`Do`:具体的参数校验逻辑

、、、、、

```

golang 里没有继承的概念，要复用成员属性 `nextHandler`,成员方法SetNext、成员方法`Run`怎么办
使用 `合成复用`的特性变相达到 "继承复用"的目的，如下：
```
一个接口(interface)

- 抽象方法`SetNext`:待实现把下一个对象的实例绑定到当前对象的 `nextHandler`属性上
- 抽象方法`Do`:待实现当前对象业务逻辑入口
- 抽象方法`Run`:待实现调用当前对象的`Do`,`nextHandler`不为空则调用`nextHandler.Do`

一个基础结构体:

- 成员属性
    + `nextHandler`：下一个等待被调用的对象实例
- 成员方法
    + 实体方法`SetNext`: 实现把下一个等待被调用的对象实例
    + 实体方法`Run`:实现调用当前对象的`Do`,`nextHandler`不为空则当用`nextHandler.Do`

子类一(参数校验)
- 合成复用基础结构
- 实现抽象方法`Do`:具体的参数校验逻辑

子类二(获取地址信息)
- 合成复用基础结构
- 实现抽象方法`Do`:具体的参数校验逻辑

。。。。。

```

## 结语 
最后总结下，「责任链模式(改)」抽象过程的核心是：
- 按职责划分：业务逻辑归类，收敛的过程。
- 对象链：把收敛之后的业务对象构成对象链，一次被执行